â€""" Sheba Finder Bot - MVP (Mobile-ready) Language: Python (python-telegram-bot v20+)
â€
â€Ready-to-deploy: Telegram bot + FastAPI webhook + polling fallback Supports:
â€
â€/start with language selection (Bangla/English)
â€
â€Find Service (location/text)
â€
â€Register as Provider flow
â€
â€Save providers to DB (SQLite by default)
â€
â€
â€Environment variables required:
â€
â€BOT_TOKENÂ Â Â Â  -> Telegram bot token
â€
â€DATABASE_URLÂ  -> optional (Postgres URL, default SQLite)
â€
â€PORTÂ Â Â Â Â Â Â Â Â  -> server port (default 8080)
â€
â€WEBHOOK_URLÂ Â  -> public HTTPS URL for Telegram webhook
â€
â€
â€IMPORTANT: Do not commit BOT_TOKEN. Revoke old token and generate a new one. """
â€
â€import os import asyncio from typing import Optional, List from fastapi import FastAPI from telegram import Update, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, MessageHandler, filters, ConversationHandler import logging
â€
â€Logging setup
â€
â€logging.basicConfig(level=logging.INFO) logger = logging.getLogger(name)
â€
â€ENV variables
â€
â€BOT_TOKEN = os.environ.get('BOT_TOKEN') PORT = int(os.environ.get('PORT', 8080)) WEBHOOK_URL = os.environ.get('WEBHOOK_URL') DATABASE_URL = os.environ.get('DATABASE_URL', 'sqlite+aiosqlite:///./data.db')
â€
â€if not BOT_TOKEN: logger.error("BOT_TOKEN is not set") raise SystemExit("BOT_TOKEN environment variable required")
â€
â€FastAPI app
â€
â€app = FastAPI()
â€
â€Telegram bot
â€
â€application = ApplicationBuilder().token(BOT_TOKEN).build()
â€
â€Conversation states
â€
â€LANG, MAIN_MENU, WAIT_LOCATION, REGISTER_NAME = range(4)
â€
â€Keyboards
â€
â€lang_kb = ReplyKeyboardMarkup([['à¦¬à¦¾à¦‚à¦²à¦¾ ğŸ‡§ğŸ‡©', 'English ğŸ‡¬ğŸ‡§']], resize_keyboard=True, one_time_keyboard=True) main_kb_bangla = ReplyKeyboardMarkup([['à¦¸à¦¾à¦°à§à¦­à¦¿à¦¸ à¦–à§à¦à¦œà§à¦¨ ğŸ”','à¦†à¦®à¦¿ à¦¸à§‡à¦¬à¦¾ à¦¦à¦¿à¦‡ ğŸ“'],['à¦®à¦¾à¦‡ à¦«à§‡à¦­à¦¾à¦°à¦¿à¦Ÿ â­','à¦¹à§‡à¦²à§à¦ª â“']], resize_keyboard=True) main_kb_english = ReplyKeyboardMarkup([['Find Service ğŸ”','I provide service ğŸ“'],['My Favorites â­','Help â“']], resize_keyboard=True)
â€
â€Handlers
â€
â€async def start(update: Update, context: ContextTypes.DEFAULT_TYPE): await update.message.reply_text("à¦¸à§à¦¬à¦¾à¦—à¦¤à¦®! à¦­à¦¾à¦·à¦¾ à¦¨à¦¿à¦°à§à¦¬à¦¾à¦šà¦¨ à¦•à¦°à§à¦¨:\nWelcome! Please choose a language:", reply_markup=lang_kb) return LANG
â€
â€async def lang_choice(update: Update, context: ContextTypes.DEFAULT_TYPE): text = update.message.text.strip() if 'à¦¬à¦¾à¦‚à¦²à¦¾' in text: context.user_data['lang'] = 'bn' await update.message.reply_text('à¦­à¦¾à¦²à§‹ à¦²à¦¾à¦—à¦²à§‹! à¦®à§‡à¦¨à§ à¦¥à§‡à¦•à§‡ à¦à¦•à¦Ÿà¦¿ à¦…à¦ªà¦¶à¦¨ à¦¬à§‡à¦›à§‡ à¦¨à¦¿à¦¨:', reply_markup=main_kb_bangla) else: context.user_data['lang'] = 'en' await update.message.reply_text('Nice! Choose an option from the menu:', reply_markup=main_kb_english) return MAIN_MENU
â€
â€async def main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE): text = update.message.text.strip() lang = context.user_data.get('lang', 'en') if 'à¦¸à¦¾à¦°à§à¦­à¦¿à¦¸' in text or 'Find Service' in text: kb = ReplyKeyboardMarkup([[KeyboardButton(text="à¦²à§‹à¦•à§‡à¦¶à¦¨ à¦¶à§‡à¦¯à¦¼à¦¾à¦° à¦•à¦°à§à¦¨", request_location=True)], ["à¦²à§‹à¦•à§‡à¦¶à¦¨ à¦Ÿà¦¾à¦‡à¦ª à¦•à¦°à§‡ à¦¦à¦¿à¦¨"]], resize_keyboard=True, one_time_keyboard=True) if lang=='bn' else ReplyKeyboardMarkup([[KeyboardButton(text="Share location", request_location=True)], ["Type area name"]], resize_keyboard=True, one_time_keyboard=True) msg = 'à¦²à§‹à¦•à§‡à¦¶à¦¨ à¦¶à§‡à¦¯à¦¼à¦¾à¦° à¦•à¦°à§à¦¨ à¦¬à¦¾ à¦Ÿà¦¾à¦‡à¦ª à¦•à¦°à§à¦¨:' if lang=='bn' else 'Share your location or type area name:' await update.message.reply_text(msg, reply_markup=kb) return WAIT_LOCATION elif 'à¦†à¦®à¦¿ à¦¸à§‡à¦¬à¦¾' in text or 'I provide service' in text: msg = 'à¦†à¦ªà¦¨à¦¾à¦° à¦¨à¦¾à¦® à¦²à¦¿à¦–à§à¦¨:' if lang=='bn' else 'Please send your name:' await update.message.reply_text(msg, reply_markup=ReplyKeyboardRemove()) return REGISTER_NAME else: msg = 'Coming soon...' if lang=='en' else 'à¦¶à§€à¦˜à§à¦°à¦‡ à¦†à¦¸à¦›à§‡...' await update.message.reply_text(msg) return MAIN_MENU
â€
â€Conversation handler
â€
â€conv_handler = ConversationHandler( entry_points=[CommandHandler('start', start)], states={ LANG: [MessageHandler(filters.TEXT & ~filters.COMMAND, lang_choice)], MAIN_MENU: [MessageHandler(filters.TEXT & ~filters.COMMAND, main_menu)] }, fallbacks=[CommandHandler('start', start)] )
â€
â€application.add_handler(conv_handler)
â€
â€FastAPI webhook
â€
â€@app.on_event("startup") async def on_startup(): await application.initialize() await application.start() if WEBHOOK_URL: await application.bot.set_webhook(WEBHOOK_URL)
â€
â€@app.on_event("shutdown") async def on_shutdown(): await application.stop() await application.shutdown()
â€
â€@app.post("/webhook") async def webhook(request: dict): update = Update.de_json(request, application.bot) await application.update_queue.put(update) return {'status': 'ok'}
â€
â€Local polling fallback (optional)
â€
â€if name == 'main': import uvicorn asyncio.run(init_db())Â  # create tables if DB exists uvicorn.run(app, host='0.0.0.0', port=PORT)
â€python-telegram-bot[core,fastapi]==20.5
â€fastapi
â€uvicorn
â€sqlalchemy[aio]
â€aiosqlite
â€python-dotenv
â€
